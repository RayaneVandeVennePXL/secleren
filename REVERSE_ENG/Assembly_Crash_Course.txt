---
Assembly Crash Course Samenvatting

Binaire code:
- Programma's worden door de CPU als binaire getallen (1en en 0en) gelezen.
- 8 bits vormen een byte, vaak weergegeven als hexadecimaal (bijv. 0xA5).

Opcodes en Operanden:
- **Opcode**: Getal dat een CPU-instructie aanduidt (bijv. b8 voor mov eax, 0x5f).
- **Operand**: Gegevens waarop de instructie werkt.

Voorbeeld:
040000:    b8 5f 00 00 00    mov eax, 0x5f
- 040000: adres van instructie
- b8: opcode (mov naar eax)
- 5f 00 00 00: operand (0x5f, little-endian)

Soorten Operanden:
1. **Immediate**: Vaste waarde, bijv. mov eax, 0x5f
2. **Register**: CPU-register, bijv. mov ebx, eax
3. **Memory**: Geheugenlocatie, bijv. mov eax, [ebx]

Registers:
- Kleine, snelle opslagplaatsen in de CPU.
- Sneller dan RAM, maar beperkt in grootte.

Belangrijkste registers (32-bit):
- EAX: Accumulator, resultaat van berekeningen
- EBX: Base register, basisadres
- ECX: Counter register, voor loops
- EDX: Data register
- ESP: Stack pointer
- EBP: Base pointer
- ESI: Source index
- EDI: Destination index

Instruction Pointer (EIP):
- Bevat adres van volgende uit te voeren instructie.

Status Flags (EFLAGS):
- Zero Flag (ZF): Resultaat nul?
- Carry Flag (CF): Overflow?
- Sign Flag (SF): Negatief?

Segment Registers:
- CS: Code segment
- DS: Data segment
- SS: Stack segment
- ES/FS/GS: Extra data segmenten

Geheugenindeling programma:
- **Code**: Uitvoerbare instructies
- **Data**: Geïnitialiseerde data
- **Heap**: Dynamisch geheugen
- **Stack**: Lokale variabelen, argumenten, return address

Voorbeeld instructie:
mov eax, [ebx]   ; laad waarde uit geheugenadres in ebx naar eax
mov ecx, 0x10    ; zet 0x10 in ecx
add eax, ecx     ; tel ecx op bij eax

TASK3 ---------------------------------------------------------------------------------
Algemene instructies:
- Instructies geven de CPU opdrachten, vaak met operanden uit registers, geheugen of vaste waarden.

MOV:
- Verplaatst een waarde van bron naar bestemming.
- Voorbeelden:
  mov eax, 0x5f      ; vaste waarde naar register
  mov ebx, eax       ; register naar register
  mov eax, [ebx]     ; waarde uit geheugen naar register

LEA:
- "Load Effective Address"; slaat het adres zelf op, niet de waarde.
- Voorbeeld:
  lea eax, [ebp+4]   ; slaat adres ebp+4 op in eax

NOP:
- "No Operation"; doet niets, gebruikt als opvulling (nop sled).
- Voorbeeld:
  nop

Shift instructies:
- Verschuiven bits in een register.
- shr (shift right), shl (shift left)
- Voorbeeld:
  shl eax, 1         ; verschuift bits in eax 1 plek naar links (maal 2)
  shr eax, 1         ; verschuift bits in eax 1 plek naar rechts (delen door 2)
- Handig voor snelle vermenigvuldiging/deling door machten van 2.

Rotate instructies:
- ROR (rotate right), ROL (rotate left); bits worden rondgedraaid in register.
- Voorbeeld:
  ror al, 1          ; roteert bits in al 1 plek naar rechts
  rol al, 1          ; roteert bits in al 1 plek naar links
- Verschil met shift: bits die eruit gaan, komen aan de andere kant weer terug.

In x86 assembly heeft de CPU verschillende flags die het resultaat van bewerkingen aangeven. 
Deze flags zijn bits in het EFLAGS-register. \
Elke flag geeft een specifieke toestand of resultaat van de laatste rekenkundige of logische operatie weer.


Belangrijkste flags in x86 assembly (EFLAGS):
- Carry Flag (CF): Zet bij overflow/borrow van hoogste bit, ook bij bitverschuivingen.
- Parity Flag (PF): Zet als laagste byte een even aantal 1-bits heeft.
- Auxiliary Flag (AF): Zet bij carry/borrow tussen bit 3 en 4 (BCD).
- Zero Flag (ZF): Zet als resultaat nul is.
- Sign Flag (SF): Zet als resultaat negatief is (hoogste bit = 1).
- Overflow Flag (OF): Zet bij overflow in signed berekeningen.
- Direction Flag (DF): Richting bij string-operaties (0 = vooruit, 1 = achteruit).
- Interrupt Enable Flag (IF): Zet hardware interrupts aan (1) of uit (0).

Flags zijn belangrijk voor voorwaardelijke sprongen en controle in assembly code.

Which flag will be set if the result of the operation is zero? (Answer in abbreviation)
ZF

Correct Answer
Which flag will be set if the result of the operation is negative? (Answer in abbreviation)
SF
Correct Answer

Rekenkundige en logische instructies in x86 assembly:

Optellen en aftrekken:
- add bestemming, waarde   ; telt waarde op bij bestemming
- sub bestemming, waarde   ; trekt waarde af van bestemming
- ZF wordt gezet als resultaat nul is, CF als er een borrow is

Vermenigvuldigen en delen:
- mul waarde   ; vermenigvuldigt waarde met eax, resultaat in edx:eax
- div waarde   ; deelt edx:eax door waarde, resultaat in eax, rest in edx

Verhogen en verlagen:
- inc eax      ; verhoogt eax met 1
- dec eax      ; verlaagt eax met 1

Logische instructies:
- and al, 0x7c ; bitwise AND, alleen 1 als beide bits 1 zijn
- or al, 0x7c  ; bitwise OR, 1 als één van beide bits 1 is
- not al       ; bitwise NOT, keert alle bits om
- xor al, 0x7c ; bitwise XOR, 1 als bits verschillend zijn
- xor al, al   ; zet register op nul (veel gebruikt)

Deze instructies zijn essentieel voor berekeningen en logica in assembly code.

Wat zijn arithmetic operations?
- Arithmetic operations (rekenkundige bewerkingen) zijn basisbewerkingen zoals optellen, aftrekken, vermenigvuldigen en delen.
- De CPU voert deze uit met speciale instructies direct op registers en geheugen.
- Ze vormen de kern van alle berekeningen in een programma en zijn essentieel voor wiskundige en logische taken in assembly.

Conditionals en branching in x86 assembly:

TEST:
- test bestemming, bron ; bitwise AND, zet ZF als resultaat 0 is
- Handig om te checken op nulwaarde

CMP:
- cmp bestemming, bron ; vergelijkt twee waarden, zet ZF of CF
- Werkt als subtractie zonder resultaat op te slaan
- ZF gezet als gelijk, CF gezet als bron > bestemming

Branching:
- Zonder branching loopt de code lineair door
- Branching verandert de Instruction Pointer en dus de volgorde van uitvoering

JMP:
- jmp locatie ; springt naar opgegeven adres

Conditionele jumps:
- jz / je : springt als ZF=1 (gelijk)
- jnz / jne : springt als ZF=0 (niet gelijk)
- jg / jl : springt als bestemming groter/kleiner dan bron (signed)
- jge / jle : springt als groter/gelijk of kleiner/gelijk (signed)
- ja / jb : springt als boven/onder (unsigned)
- jae / jbe : springt als boven/gelijk of onder/gelijk (unsigned)

Met deze instructies kan de CPU beslissingen nemen en de controleflow van het programma aanpassen.

De stack in x86 assembly:
- De stack is een LIFO-geheugenstructuur: laatste erin, eerste eruit.
- Wordt gebruikt voor tijdelijke opslag van data, return-adressen en functie-argumenten.

PUSH:
- push bron ; plaatst waarde van bron bovenop de stack, ESP wordt verlaagd
- pusha/pushad ; slaat alle algemene registers op de stack

POP:
- pop bestemming ; haalt waarde van bovenop de stack en zet in bestemming, ESP wordt verhoogd
- popa/popad ; herstelt alle algemene registers vanaf de stack

CALL:
- call locatie ; roept een functie aan, slaat return-adres op de stack
- Bij een functiecall worden argumenten vaak op de stack gezet, en de stack wordt aangepast (prologue/epilogue)

De stack is cruciaal voor functie-aanroepen, lokale variabelen en het bewaren van de staat van registers.








